// Copyright 2025 Terramate GmbH
// SPDX-License-Identifier: MPL-2.0

package core_test

import (
	"io"
	"os"
	"path/filepath"
	"runtime"
	"testing"

	. "github.com/terramate-io/terramate/e2etests/internal/runner"
	"github.com/terramate-io/terramate/plugin"
	"github.com/terramate-io/terramate/test"
	"github.com/terramate-io/terramate/test/sandbox"
)

func TestGRPCPluginCommandExecution(t *testing.T) {
	t.Parallel()
	s := sandbox.New(t)
	cli := NewCLI(t, s.RootDir())
	installGRPCPlugin(t, cli.UserDir())

	res := cli.Run("hello")
	AssertRunResult(t, res, RunExpected{
		Stdout: "hello\n",
		Status: 0,
	})

	res = cli.Run("fail")
	AssertRunResult(t, res, RunExpected{
		Stderr: "plugin failure\n",
		Status: 2,
	})
}

func TestGRPCPluginHCLSchema(t *testing.T) {
	t.Parallel()
	s := sandbox.New(t)
	s.BuildTree([]string{"s:stack"})
	cli := NewCLI(t, s.RootDir())
	installGRPCPlugin(t, cli.UserDir())

	marker := filepath.Join(s.RootDir(), "plugin.marker")
	cli.AppendEnv = append(cli.AppendEnv, "TM_E2E_GRPC_MARKER="+marker)

	test.WriteFile(t, s.RootDir(), "plugin.tm.hcl", `
pluginblock "demo" {
  value = "ok"
}
`)

	res := cli.Run("list")
	AssertRunResult(t, res, RunExpected{
		StdoutRegex: "stack",
		Status:      0,
	})

	content, err := os.ReadFile(marker)
	if err != nil {
		t.Fatalf("read marker: %v", err)
	}
	if string(content) != "pluginblock:1" {
		t.Fatalf("unexpected marker content: %s", string(content))
	}
}

func TestGRPCPluginPostInitHooks(t *testing.T) {
	t.Parallel()
	s := sandbox.New(t)
	s.BuildTree([]string{"s:stack"})
	cli := NewCLI(t, s.RootDir())
	installGRPCPlugin(t, cli.UserDir())

	cli.AppendEnv = append(cli.AppendEnv, "TM_E2E_GRPC_POSTINIT_MARKER=postinit.marker")

	res := cli.Run("list")
	AssertRunResult(t, res, RunExpected{
		StdoutRegex: "stack",
		Status:      0,
	})

	content, err := os.ReadFile(filepath.Join(s.RootDir(), "postinit.marker"))
	if err != nil {
		t.Fatalf("read postinit marker: %v", err)
	}
	if string(content) != "post-init" {
		t.Fatalf("unexpected postinit marker: %s", string(content))
	}
}

func TestGRPCPluginGenerateOverride(t *testing.T) {
	t.Parallel()
	s := sandbox.New(t)
	s.BuildTree([]string{"s:stack"})
	cli := NewCLI(t, s.RootDir())
	installGRPCPlugin(t, cli.UserDir())

	res := cli.Run("generate")
	AssertRunResult(t, res, RunExpected{
		StdoutRegex: "grpc generate",
		Status:      0,
	})

	content, err := os.ReadFile(filepath.Join(s.RootDir(), "generated.txt"))
	if err != nil {
		t.Fatalf("read generated file: %v", err)
	}
	if string(content) != "generated by grpc plugin" {
		t.Fatalf("unexpected generated content: %s", string(content))
	}
}

func TestPluginAddDetectsGRPCProtocol(t *testing.T) {
	t.Parallel()
	s := sandbox.New(t)
	cli := NewCLI(t, s.RootDir())
	sourceDir := test.TempDir(t)

	suffix := ""
	if runtime.GOOS == "windows" {
		suffix = ".exe"
	}
	destBinary := filepath.Join(sourceDir, "terramate"+suffix)
	copyExecutableFile(t, GRPCPluginPath, destBinary)

	res := cli.Run("plugin", "add", "grpc-local", "--source", sourceDir)
	AssertRunResult(t, res, RunExpected{
		IgnoreStdout: true,
		Status:       0,
	})

	manifest, err := plugin.LoadManifest(plugin.PluginDir(cli.UserDir(), "grpc-local"))
	if err != nil {
		t.Fatalf("load manifest: %v", err)
	}
	if manifest.Protocol != plugin.ProtocolGRPC {
		t.Fatalf("expected grpc protocol, got %s", manifest.Protocol)
	}
}

func installGRPCPlugin(t *testing.T, userDir string) {
	t.Helper()
	pluginDir := plugin.PluginDir(userDir, "grpc-test")
	if err := os.MkdirAll(pluginDir, 0o700); err != nil {
		t.Fatalf("mkdir: %v", err)
	}
	suffix := ""
	if runtime.GOOS == "windows" {
		suffix = ".exe"
	}
	destBinary := filepath.Join(pluginDir, "terramate"+suffix)
	copyExecutableFile(t, GRPCPluginPath, destBinary)
	manifest := plugin.Manifest{
		Name:     "grpc-test",
		Version:  "0.1.0",
		Type:     plugin.TypeGRPC,
		Protocol: plugin.ProtocolGRPC,
		Binaries: map[plugin.BinaryKind]plugin.Binary{
			plugin.BinaryCLI: {Path: filepath.Base(destBinary)},
		},
	}
	if err := plugin.SaveManifest(pluginDir, manifest); err != nil {
		t.Fatalf("save manifest: %v", err)
	}
}

func copyExecutableFile(t *testing.T, src, dest string) {
	t.Helper()
	in, err := os.Open(src)
	if err != nil {
		t.Fatalf("open source: %v", err)
	}
	defer func() {
		_ = in.Close()
	}()
	out, err := os.OpenFile(dest, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o700)
	if err != nil {
		t.Fatalf("open dest: %v", err)
	}
	if _, err := io.Copy(out, in); err != nil {
		_ = out.Close()
		t.Fatalf("copy: %v", err)
	}
	if err := out.Close(); err != nil {
		t.Fatalf("close dest: %v", err)
	}
}
